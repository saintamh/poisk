# See test_type_checking.py

test_cases:

  ### regex search

  - name: regex find_all happy path
    expected_error: null
    code: |-
      words = find_all(r'\w+', 'The quick brown fox')
      [w.strip() for w in words]

  - name: regex find_all returns strings
    expected_error: '"str" has no attribute "not_a_known_str_attribute"'
    code: |-
      words = find_all(r'\w+', 'The quick brown fox')
      [w.not_a_known_str_attribute for w in words]

  - name: regex find_all requires string needle
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      find_all(1, 'The quick brown fox')

  - name: regex find_all requires non-null needle
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      find_all(None, 'The quick brown fox')

  - name: regex find_all can take a `parse` that maps from str
    expected_error: null
    code: |-
      numbers = find_all(r'\d+', '1 2 3', parse=int)
      [abs(n) for n in numbers]

  - name: regex find_all with parse=int returns a list of ints
    expected_error: '"int" has no attribute "not_a_known_int_attribute"'
    code: |-
      numbers = find_all(r'\d+', '1 2 3', parse=int)
      [n.not_a_known_int_attribute for n in numbers]

  - name: regex find_all `parse` must accept str as input
    expected_error: Argument "parse" to "find_all" has incompatible type
    code: |-
      numbers = find_all(r'\d+', '1 2 3', parse=abs)

  - name: regex find_all accepts `flags` kwarg
    expected_error: null
    code: |-
      words = find_all(r'[a-z]+', 'The quick brown fox', flags=re.I)

  - name: regex find_all only accepts `flags` kwarg
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      words = find_all(r'[a-z]+', 'The quick brown fox', unknown_kwarg=re.I)


  ### regex search using a compiled pattern

  - name: compiled regex find_all happy path
    expected_error: null
    code: |-
      words = find_all(re.compile(r'\w+'), 'The quick brown fox')
      [w.strip() for w in words]

  - name: compiled regex find_all returns strings
    expected_error: '"str" has no attribute "not_a_known_str_attribute"'
    code: |-
      words = find_all(re.compile(r'\w+'), 'The quick brown fox')
      [w.not_a_known_str_attribute for w in words]

  - name: compiled regex find_all can take a `parse` that maps from str
    expected_error: null
    code: |-
      numbers = find_all(re.compile(r'\d+'), '1 2 3', parse=int)
      [abs(n) for n in numbers]

  - name: compiled regex find_all with parse=int returns a list of ints
    expected_error: '"int" has no attribute "not_a_known_int_attribute"'
    code: |-
      numbers = find_all(re.compile(r'\d+'), '1 2 3', parse=int)
      [n.not_a_known_int_attribute for n in numbers]

  - name: compiled regex find_all `parse` must accept str as input
    expected_error: Argument "parse" to "find_all" has incompatible type
    code: |-
      numbers = find_all(re.compile(r'\d+'), '1 2 3', parse=abs)

  - name: compiled regex find_all doesn't accept `flags` kwarg
    # because the call would fail anyway
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      words = find_all(re.compile(r'[a-z]+'), 'The quick brown fox', flags=re.I)

  - name: regex find_all doesn't accept unknown kwargs either
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      words = find_all(re.compile(r'[a-z]+'), 'The quick brown fox', unknown_kwarg=re.I)


  ### xpath search

  - name: xpath findall happy path
    expected_error: null
    code: |-
      titles = find_all('/h1', lxml.etree.fromstring('<h1>Title!</h1>'))
      print([t.text for t in titles])

  - name: xpath find_all returns a list of elements
    expected_error: '"_Element" has no attribute "not_a_known_element_attribute"'
    code: |-
      titles = find_all('/h1', lxml.etree.fromstring('<h1>Title!</h1>'))
      print([t.not_a_known_element_attribute for t in titles])

  - name: xpath find_all needle must be str
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      find_all(1, lxml.etree.fromstring('<h1>Title!</h1>'))

  - name: xpath find_all needle must be non-null
    expected_error: No overload variant of "find_all" matches argument types
    code: |-
      find_all(None, lxml.etree.fromstring('<h1>Title!</h1>'))

  - name: xpath find_all accepts a `parse` that accepts XPathResult as input
    expected_error: null
    code: |-
      titles = find_all('h1/text()', lxml.etree.fromstring('<h1>Title!</h1>'), parse=str)
      print([t.upper() for t in titles])

  - name: xpath find_all accepts an int `parse`
    expected_error: null
    code: |-
      ids = find_all('a/@id', lxml.etree.fromstring('<a id="5" />'), parse=int)
      print([10 ** i for i in ids])

  - name: xpath find_all with parse returns a list of that type
    expected_error: '"str" has no attribute "not_a_known_str_attribute"'
    code: |-
      titles = find_all('h1/text()', lxml.etree.fromstring('<h1>Title!</h1>'), parse=str)
      print([t.not_a_known_str_attribute for t in titles])

  - name: xpath find_all `parse` must accept XPathResult as input
    expected_error: Argument "parse" to "find_all" has incompatible type
    code: |-
      find_all('h1/text()', lxml.etree.fromstring('<h1>Title!</h1>'), parse=abs)


  ### callable search

  - name: callable find_all happy path
    expected_error: null
    code: |-
      import math
      def is_even(number: int) -> bool:
        return number % 2 == 0
      even = find_all(is_even, range(10))
      list(map(math.log, even))

  - name: callable find_all works with any iterable
    expected_error: null
    code: |-
      import math
      from typing import Iterable

      class MyIterable(Iterable[int]):
        def __iter__(self):
          yield 1
          yield 2
          yield 3

      def is_even(number: int) -> bool:
        return number % 2 == 0

      even = find_all(is_even, MyIterable())
      list(map(math.log, even))

  - name: callable find_all can take a `parse` that maps to a different type
    expected_error: null
    code: |-
      from pathlib import Path
      from typing import Iterable

      class MyIterable(Iterable[int]):
        def __iter__(self):
          yield 1
          yield 2
          yield 3

      def is_even(number: int) -> bool:
        return number % 2 == 0

      def as_path(number: int) -> Path:
        return Path(str(number))

      even_paths = find_all(is_even, MyIterable(), parse=as_path)
      [p.glob('*') for p in even_paths]
